# Использование альтернатив при синтаксическом разборе

В главе 7 "[Синтаксический анализатор строковых данных](../07-parsing-string-data)" мы вкратце представили комбинатор выбора [`<|>`](http://www.quanttec.com/fparsec/reference/primitives.html#members.:60::124::62:):

```fsharp
val (<|>): Parser<'a,'u> -> Parser<'a,'u> -> Parser<'a,u>
```

который позволяет вам поддерживать несколько альтернативных вариантов.

Например, в той же главе мы использовали `<|>` для объединения синтаксического анализатора для не экранированных символов и анализатора для экранированных символов в новый анализатор, который поддерживает оба варианта: `normalChar <|> escapedChar`.

Другим примером, показывающим, как работает `<|>` является следующий синтаксический анализатор для разбора строкового представления булевых значений:

```fsharp
let boolean = 
  (stringReturn "true"  true) <|>
  (stringReturn "false" false)
```

Здесь мы использовали синтаксический анализатор [`stringReturn`](http://www.quanttec.com/fparsec/reference/charparsers.html#members.stringReturn), который принимает в качестве первого аргумента строку, и, в случае успеха, возвращает значение, указанное вторым аргументом.

Протестируем синтаксический анализатор `boolean` на примерах:

```fsharp
> test boolean "false";;
Success: false
> test boolean "true";;
Success: true
> test boolean "tru";;
Failure: Error in Ln: 1 Col: 1
tru
^
Expecting: 'false' or 'true'
```

Поведение комбинатора `<|>` имеет две важные характеристики:
* `<|>` Правая часть синтаксического анализатора выполняется, если синтаксический анализатор левой части не завершился с фатальной ошибкой и без изменения состояния. Комбинатор не реализует правило самого длинного совпадения.
* Однако, комбинатор пытается использовать правый синтаксический анализатор, если левый синтаксический анализатор при завершении вызывает *нет данных для обработки*.

Следствием второго пункта является то, что следующий тест завершился неудачно, потому что синтаксический анализатор в левой части `<|>` получает пробелы перед сбоем:

```fsharp
> test ((ws >>. str "a") <|> (ws >>. str "b")) " b";;
Failure: Error in Ln: 1 Col: 2
 b
 ^
Expecting: 'a'
```

К счастью, мы можем легко исправить этот синтаксический анализатор, выделив `ws`:

```fsharp
> test (ws >>. (str "a" <|> str "b")) " b";;
Success: "b"
```

Если вам интересно, почему `<|>` ведет себя таким образом и как вы можете обрабатывать ситуации, в которых вам нужно чтобы  `<|>` пытался исполнять альтернативный синтаксический анализатор, даже если первый синтаксический анализатор вызвал ошибку после обработки входных данных смотрите главы [5.6 Parsing alternatives](http://www.quanttec.com/fparsec/users-guide/parsing-alternatives.html) и [5.7 Looking ahead and backtracking](http://www.quanttec.com/fparsec/users-guide/looking-ahead-and-backtracking.html) в руководстве пользователя.

Если вы хотите использовать более двух альтернативных синтаксических анализаторов, вы можете комбинировать несколько операторов `<|>`, например, в `p1 <|> p2 <|> p3 <|> ...`, или вы можете использовать комбинатор [`choice`](http://www.quanttec.com/fparsec/reference/primitives.html#members.choice), который принимает последовательность синтаксических анализаторов в качестве аргумента, например `choice [ p1 ; p2 ; p3 ; ... ]`.