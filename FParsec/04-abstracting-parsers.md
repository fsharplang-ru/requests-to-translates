# Абстрактные синтаксические анализаторы

Одной из самых сильных сторон FParsec является легкость, с которой вы можете определить свои собственные абстрактные синтаксические анализаторы.

Возьмем, к примеру `floatBetweenBrackets` из предыдущей главы. Если вы намерены также разобрать другие элементы между строк, вы можете определить свой собственный специализированный комбинатор для этой цели:
```fsharp
let betweenStrings s1 s2 p = str s1 >>. p .>> str s2
```

Затем можно определить `floatInBrackets` и другие синтаксические анализаторы с помощью этого комбинатора:
```fsharp
let floatBetweenBrackets = pfloat |> betweenStrings "[" "]"
let floatBetweenDoubleBrackets = pfloat |> betweenStrings "[[" "]]"
```

**_Примечание_**

>В том случае, если вы новичок в F#:
>```fsharp
>pfloat |> betweenStrings "[" "]"
>```
>это просто другая форма записи для 
>```fsharp
>betweenStrings "[" "]" pfloat
>```

В тот момент, как вы заметите, что вам часто нужно применять синтаксический анализатор между двумя другими, вы можете пойти дальше, представив функцию `betweenStrings` следующим образом:
```fsharp
let between pBegin pEnd p  = pBegin >>. p .>> pEnd
let betweenStrings s1 s2 p = p |> between (str s1) (str s2)
```

На самом деле, вам не нужно определять `between`, потому что такой комбинатор уже [есть](http://www.quanttec.com/fparsec/reference/primitives.html#members.between) в библиотеке FParsec.

Все это, конечно, простые примеры. Но поскольку FParsec это лишь библиотека F#, а не какой-то внешний инструмент для генерации синтаксического анализатора, здесь нет никаких ограничений на абстракции, которые можно определять. Вы можете написать функцию, которая принимает любые, необходимые вам, входные данные, выполняет некоторые сложные произвольные вычисления, а затем возвращает синтаксический анализатор специального назначения или комбинатор синтаксических анализаторов.

Например, вы можете написать функцию, которая принимает шаблон регулярного выражения в качестве входных данных и возвращает `Parser` для разбора данных, соответствующих этому шаблону. Эта функция может использовать другой синтаксический анализатор для разбора шаблона регулярного выражения в [АСД](https://ru.wikipedia.org/wiki/Абстрактное_синтаксическое_дерево), а затем компилировать его в функцию синтаксического анализатора специального назначения. Кроме того, она может построить регулярное выражение .NET из шаблона, а затем вернуть функцию синтаксического анализатора, которая использует [API](https://ru.wikipedia.org/wiki/API) модуля `CharStream` из FParsec для непосредственного применения регулярного выражения к входному потоку (на самом деле это как раз то, что делает встроенный парсер [regex](http://www.quanttec.com/fparsec/reference/charparsers.html#members.regex)).

Другой пример &mdash; расширяемое приложение синтаксического анализа. Сохранив функции синтаксического анализатора в словаре или другой структуре данных и определив расширяемый протокол, вы можете разрешить плагинам динамически регистрировать новые синтаксические анализаторы или изменять существующие.

