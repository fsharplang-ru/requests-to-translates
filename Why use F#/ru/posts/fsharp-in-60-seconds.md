---
layout: post
title: "Синтаксис F# за 60 секунд"
description: "Очень краткий обзор того, как читать F#-код"
nav: why-use-fsharp
seriesId: "Зачем использовать F#?"
seriesOrder: 2
---
Вот очень быстрый обзор того, как читать F#-код, для незнакомых с синтаксисом данного языка.

Этот обзор, конечно же, не очень подробный, но его должно быть достаточно для того, чтобы вы могли, читая фрагменты кода в данном цикле статей, понимать их смысл. Не волнуйтесь, если что-то из них вам останется неясным, т.к. я поясню всё более детально, когда мы подберёмся к реальным примерам кода.

Два основных различия между синтаксисами F# и стандартного C-подобного языка следующие:

* Для отделения блоков кода не используются фигурные скобки. Вместо этого применяются отступы (похожим образом делается в Python).
* Для разделения параметров [функций] используются пробелы, а не запятые.

Некоторые находят синтаксис F# отталкивающим. Если вы один из них, то специально для вас привожу цитату:

>"Улучшать свою нотацию таким образом, чтобы не (смущать/приводить в замешательство) людей в первые 10 минут её чтения, но при этом способствовать ухудшению читаемости (после/потом/позже), есть очень плохая ошибка."
> (Дэвид МакАйвер, из [(поста/статьи) о синтаксисе Scala](http://rickyclarkson.blogspot.co.uk/2008/01/in-defence-of-0l-in-scala.html)).

Лично я думаю, что синтаксис F# очень (ясен/понятен/чёток) и простой, когда к нему привыкаешь. Во многих аспектах он проще, чем синтаксис C#, с меньшим количеством ключевых слов и исключений.

Фрагмент кода ниже -- простой F#-скрипт, демонстрирующий большинство понятий, необходимых вам на регулярной основе.

Я призываю вас опробовать данный код в интерактивном режиме и немного "поиграться" с ним! Или же:

* (Введите/перепечатайте) его в F#-скрипт-файл (с расширением .fsx) и отправьте его на исполнение в интерактивное окно (F# Interactive). Более подробно о том, как это делается, смотрите на странице ["установка и использование F#"].
* Также можно запустить этот код в интерактивном окне непосредственно. Не забывайте всегда ставить `;;` в конце строки для указания интерпретатору, что вы закончили ввод и готовы его (вычислить/запустить).

```fsharp
//однострочные комментарии начинаются с двойного слэша
(*
    многострочные комментарии помещаются между двумя скобками такого вида: (* . . . *)
*)

// ======== "Переменные" (но на самом деле не переменные)" ======
// С помощью ключевого слова "let" (задаётся/определяется) новое значение (неизменяемое)
let myInt = 5
let myFloat = 3.14
let myString = "hello"  //заметьте, в объявлении типов нет необходимости

// ======== Списки ============
let twoToFive = [2; 3; 4; 5]        // С помощью квадратных скобок
                                 // задаётся список, разделителем элементов
                                 // в котором является точка с запятой.

let oneToFive = 1 :: twoToFive   // :: создаёт список с новым 1-м элементом
// Результат: [1; 2; 3; 4;5 ]
let zeroToFive = [0; 1] @ twoToFive   // @ используется для
                                     // конкатенации двух списков

// ВАЖНО: в качестве разделителей никогда не используются запятые,
// только точки с запятой!

// ======== Функции ========
// С помощью ключевого слова "let" также задаётся и именнованная функция.
let square x = x * x          // Заметьте, что круглые скобки не используются.
square 3                      // А теперь выполним функцию.
                              // Опять же, никаких круглых скобок.

let add x y = x + y           // не пишите add (x,y)! Это означает
                              // нечто совершенно другое.
add 2 3                       // А теперь выполняем функцию.

// для задания многострочной функции просто используйте отступы.
// Точки с запятой не требуются.
let evens list =
    let isEven x = x % 2 = 0  // Задаём функцию "isEven" как внутреннюю ("вложенную")
    List.filter isEven list   // List.filter -- это библиотечная функция
                              // с двумя параметрами:
                              // булевой функцией и списком на обработку
                              // (a boolean function and a list to work on)

evens oneToFive               // А теперь выполним функцию.

// Вы можете использовать круглые скобки для уточнения
// (приоритета/последовательности)применения параметров.
// В данном примере сначала примените "map" к двум аргументам,
// а затем к результату этого примените "sum".
// Без расстановки круглых скобок "List.map" будет считаться
// аргументов функции "List.sum"
let sumOfSquaresTo100 =
    List.sum ( List.map square [1 .. 100] )

// Вы можете передавать выходное значение одной операции на вход к следующей
// (как по конвейеру), используя оператор "|>".
// Вот, например, та же функция sumOfSquares, написанная с использованием
// этих, так называемых, конвейеров
let sumOfSquaresTo100piped =
    [1 .. 100] |> List.map square |> List.sum  // "square" была задана ранее

// вы можете задавать лямбда-функции (анонимные функции)
// с помощью ключевого слова "fun"
let sumOfSquaresTo100withFun =
    [1 .. 100] |> List.map (fun x -> x * x) |> List.sum

// В F# возвращаемое значение задаётся неявно -- "return" не требуется.
// Функция всегда возвращает значение последнего
// определённого в ней выражения.

// ======== Сопоставление с образцом (Pattern Matching) ========
// match..with.. -- это (улучшенная/"прокачанная") инструкция case/switch.
let simplePatternMatch =
    let x = "a"
    match x with
    | "a" -> printfn "x is a"
    | "b" -> printfn "x is b"
    | _ -> printfn "x is something else"  // нижнее подчёркивание
                                          // сопоставляется с чем угодно

// Some(..) и None -- приблизительные аналоги (?) обёрток для Nullable (?)
let validValue = Some(99)
let invalidValue = None

// В данном примере match..with сопоставляется с "Some" и "None"
// и в то же время "распаковывает" значение, "хранящееся" в "Some".
let optionPatternMatch input =
    match input with
    | Some i -> printfn "input is an int=%d" i
    | None -> printfn "input is missing"

optionPatternMatch validValue
optionPatternMatch invalidValue

// ========= (Сложные/составные) типы данных =========

// К типу-кортежу относятся пары, тройки и т.п.
// В кортежах используются запятые (в качестве разделителей).
let twoTuple = 1, 2
let threeTuple = "a", 2, true

// У типов-записей имеются именованные поля.
// Разделителями являются точки с запятой.
type Person = { First : string; Last : string }
let person1 = { First = "john"; Last = "Doe" }

// С помощью типов-объединений описываются вариативные значения.
// Разделителем является вертикальная черта.
type Temp =
    | DegreesC of float
    | DegreesF of float
let temp = DegreesF 98.6

// Типы могут комбинироваться рекурсивно различными сложными способами.
// Например, вот тип-объединение, содержащий в себе список этого же типа:
type Employee =
    | Worker of Person
    | Manager of Employee list
let jdoe = { First = "John"; Last = "Doe" }
let worker = Worker jdoe

// ========= Текстовый вывод =========
// Функции printf/printfn очень похои на функции
// Console.Write/WriteLine из C#.
printfn "Printing an int %i, a float %f, a bool %b" 1 2.0 true
printfn "A string %s, and something generic %A" "hello" [1; 2; 3; 4]

// все сложные типы имеют встроенное наглядное текстовое представление (вывод)
printfn "twoTuple=%A,\nPerson=%A,\nTemp=%A,\nEmployee=%A"
         twoTuple person1 temp worker

// Также имеются функции sprintf/sprintfn
// для форматированного вывода в строку, подобно String.Format.


```

Ну а теперь давайте приступим к сравнению простых фрагментов F#-кода с эквивалентными им фрагментами кода на C#.
